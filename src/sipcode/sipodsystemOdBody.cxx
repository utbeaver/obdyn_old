// C++ interface wrapper code.
//
// Generated by SIP 3.10.2 (3.10.2-205) on Wed Mar 27 22:12:12 2019

#include "sipodsystemDeclodsystem.h"
#include "sipodsystemOdBody.h"


PyObject *sipClass_OdBody;

static void sipDealloc_OdBody(sipThisType *);

static PyTypeObject sipType_OdBody = {
	PyObject_HEAD_INIT(&PyType_Type)
	0,
	sipWrapperTypeName,
	sizeof (sipThisType),
	0,
	(destructor)sipDealloc_OdBody,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	Py_TPFLAGS_DEFAULT,
};

static PyObject *sipDo_OdBody_setMass(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 99 "python\od_system.sip"
       double mass;
       OdBody *pB;
       if (sipParseArgs(&sipArgsParsed,sipArgs,  "md", sipThisObj, sipClass_OdBody, &pB, &mass)){  
         if(pB) {
          pB->setMass(mass);
         }
       }
       return Py_BuildValue("s", "value set!");
#line 52 "sipodsystemOdBody.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdBody,sipName_setMass);

	return NULL;
}

static PyObject *sipDo_OdBody_setI(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 110 "python\od_system.sip"
      int i;
      double I[9];
      OdBody *pB;
      PyObject *temp_py;
      PyObject *_I;
      if (sipParseArgs(&sipArgsParsed,sipArgs,  "mO", sipThisObj, sipClass_OdBody, &pB, &_I)) {  
         if(pB) {
           for(i=0; i<9; i++) {
	            temp_py = PyList_GetItem(_I, i);
              I[i] = PyFloat_AsDouble(temp_py);
           }
         }
         pB->setI(I);
      }
      return Py_BuildValue("s", "value set!");
#line 83 "sipodsystemOdBody.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdBody,sipName_setI);

	return NULL;
}

static PyObject *sipDo_OdBody_info(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 129 "python\od_system.sip"
//     std::string msg;
     char msg[1000];
     OdBody *pB;
     char* pmsg = msg;
     if (sipParseArgs(&sipArgsParsed,sipArgs,  "m", sipThisObj, sipClass_OdBody, &pB))  
     {
	if (pB) { 	
	  pmsg= pB->info(pmsg);
	} 
     }
     return  Py_BuildValue("s", msg);
#line 110 "sipodsystemOdBody.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdBody,sipName_info);

	return NULL;
}

static PyObject *sipDo_OdBody_add_cm_marker(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 143 "python\od_system.sip"
     OdMarker *pM;
     PyObject* pO;
     OdBody *pB;
     int flag = 0;
     std::string msg="";
     if (sipParseArgs(&sipArgsParsed,sipArgs,  "mO", sipThisObj, sipClass_OdBody, &pB, &pO))  
     {
    	int iserrp = 0;
        pM = sipForceConvertTo_OdMarker(pO, &iserrp);
	      if(iserrp) msg += "conversion to OdMarker fails";
	      if (!iserrp && pB) { 	
	        pB->add_cm_marker(pM);
	        flag = 1;
	        msg += "Cm Marker is added!";
	      } 
     }
     return  Py_BuildValue("s", msg.c_str());
#line 143 "sipodsystemOdBody.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdBody,sipName_add_cm_marker);

	return NULL;
}

static PyObject *sipDo_OdBody_add_marker(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 164 "python\od_system.sip"
     int flag = 0;
     OdMarker *pM;
     PyObject* pO;
     OdBody *pB;
     std::string msg="";
     if (sipParseArgs(&sipArgsParsed,sipArgs,  "mO", sipThisObj, sipClass_OdBody, &pB, &pO))  
     {
    	int iserrp = 0;
        pM = sipForceConvertTo_OdMarker(pO, &iserrp);
	if(iserrp) msg += "conversion to OdMarker fails";
	if(!iserrp && pB) {
	  pB->add_marker(pM, 0);
	  flag = 1;
	  msg += "Global Marker is added!";
 	} 
     }
     return  Py_BuildValue("s", msg.c_str());
#line 176 "sipodsystemOdBody.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdBody,sipName_add_marker);

	return NULL;
}

static PyObject *sipDo_OdBody_add_markerg(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 185 "python\od_system.sip"
     int flag = 0;
     OdMarker *pM;
     PyObject* pO;
     OdBody *pB;
     std::string msg="";
     if (sipParseArgs(&sipArgsParsed,sipArgs,  "mO", sipThisObj, sipClass_OdBody, &pB, &pO))  
     {
    	int iserrp = 0;
        pM = sipForceConvertTo_OdMarker(pO, &iserrp);
	if(iserrp) msg += "conversion to OdMarker fails";
	if(!iserrp && pB) {
	  pB->add_marker(pM, 1);
	  flag = 1;
	  msg += "Marker is added!";
 	} 
     }
     return  Py_BuildValue("s", msg.c_str());
#line 209 "sipodsystemOdBody.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdBody,sipName_add_markerg);

	return NULL;
}

// Cast a pointer to a type somewhere in its superclass hierarchy.

const void *sipCast_OdBody(const void *ptr,PyObject *targetClass)
{
	if (targetClass == sipClass_OdBody)
		return ptr;

	return NULL;
}

static void sipDealloc_OdBody(sipThisType *sipThis)
{
	if (sipThis -> u.cppPtr != NULL)
	{

		if (sipIsPyOwned(sipThis))
		{
			Py_BEGIN_ALLOW_THREADS

			delete (OdBody *)sipThis -> u.cppPtr;

			Py_END_ALLOW_THREADS
		}
	}

	sipDeleteThis(sipThis);
}

PyObject *sipNew_OdBody(PyObject *sipSelf,PyObject *sipArgs)
{
	static sipExtraType et = {
		sipCast_OdBody
	};

	int sipFlags = SIP_PY_OWNED;
	int sipArgsParsed = 0;
	sipThisType *sipThis = NULL;
	OdBody *sipCpp = NULL;

	// See if there is something pending.

	sipCpp = (OdBody *)sipGetPending(&sipFlags);

	if (sipCpp == NULL)
	{
#line 88 "python\od_system.sip"
     int id;
     PyObject *pystr;
     if (sipParseArgs(&sipArgsParsed,sipArgs, "iO", &id, &pystr)) {
	    char* pstr = PyString_AsString(pystr);
	    Py_BEGIN_ALLOW_THREADS
	    sipCpp = new OdBody(id, pstr);
      Py_END_ALLOW_THREADS
     }  
#line 273 "sipodsystemOdBody.cxx"
	}

	if (sipCpp == NULL)
	{
		OdBody * a0;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"J1",sipClass_OdBody,&a0))
		{
			Py_BEGIN_ALLOW_THREADS
			sipCpp = new OdBody(*a0);
			Py_END_ALLOW_THREADS
		}
	}

	if (sipCpp == NULL)
	{
		sipNoCtor(sipArgsParsed,sipName_OdBody);
		return NULL;
	}

	// Wrap the object.

	if ((sipThis = sipCreateThis(sipSelf,sipCpp,&sipType_OdBody,sipFlags,&et)) == NULL)
	{
		if (sipFlags & SIP_PY_OWNED)
		{
			Py_BEGIN_ALLOW_THREADS

			delete (OdBody *)sipCpp;

			Py_END_ALLOW_THREADS
		}

		return NULL;
	}

	Py_INCREF(Py_None);
	return Py_None;
}

static PyMethodDef lazyMethods_OdBody[] = {
	{sipName_add_cm_marker, sipDo_OdBody_add_cm_marker, METH_VARARGS, NULL},
	{sipName_add_marker, sipDo_OdBody_add_marker, METH_VARARGS, NULL},
	{sipName_add_markerg, sipDo_OdBody_add_markerg, METH_VARARGS, NULL},
	{sipName_info, sipDo_OdBody_info, METH_VARARGS, NULL},
	{sipName_setI, sipDo_OdBody_setI, METH_VARARGS, NULL},
	{sipName_setMass, sipDo_OdBody_setMass, METH_VARARGS, NULL}
};

sipLazyAttrDef sipClassAttrTab_OdBody = {
	0, NULL,
	sizeof (lazyMethods_OdBody) / sizeof (PyMethodDef), lazyMethods_OdBody,
	0, NULL
};

OdBody *sipForceConvertTo_OdBody(PyObject *valobj,int *iserrp)
{
	if (*iserrp || valobj == NULL)
		return NULL;

	if (valobj == Py_None || sipIsSubClassInstance(valobj,sipClass_OdBody))
		return (OdBody *)sipConvertToCpp(valobj,sipClass_OdBody,iserrp);

	sipBadClass(sipName_OdBody);

	*iserrp = 1;

	return NULL;
}
