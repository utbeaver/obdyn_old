// C++ interface wrapper code.
//
// Generated by SIP 3.10.2 (3.10.2-205) on Wed Mar 27 22:12:12 2019

#include "sipodsystemDeclodsystem.h"
#include "sipodsystemOdJointForce.h"


PyObject *sipClass_OdJointForce;

static void sipDealloc_OdJointForce(sipThisType *);

static PyTypeObject sipType_OdJointForce = {
	PyObject_HEAD_INIT(&PyType_Type)
	0,
	sipWrapperTypeName,
	sizeof (sipThisType),
	0,
	(destructor)sipDealloc_OdJointForce,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	Py_TPFLAGS_DEFAULT,
};

static PyObject *sipDo_OdJointForce_set_expression(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 761 "python\od_system.sip"
     char* expr;
     std::string msg="";
     PyStringObject *PyStr;
     OdJointForce *pC;
     if (sipParseArgs(&sipArgsParsed,sipArgs,  "mO", sipThisObj, sipClass_OdJointForce, &pC, &PyStr))
     {
        int iserrp=0;
	     expr = PyString_AsString((PyObject*)PyStr);
	     pC->set_expr(expr);
	     msg += "expression is set!";
     }  
     return  Py_BuildValue("s", msg.c_str());
#line 56 "sipodsystemOdJointForce.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdJointForce,sipName_set_expression);

	return NULL;
}

static PyObject *sipDo_OdJointForce_set_joint(PyObject *sipThisObj,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
#line 777 "python\od_system.sip"
     std::string msg="";
     OdJoint *pM;
     PyObject *pO;
     OdJointForce *pC;
     int flag = 0;
     if (sipParseArgs(&sipArgsParsed,sipArgs,  "mO", sipThisObj, sipClass_OdJointForce, &pC, &pO))  
     {
        int iserrp=0;
	     pM = sipForceConvertTo_OdJoint(pO, &iserrp);
        if(pC && !iserrp) {
	           pC->setJoint(pM);
	           flag = 1;
	           msg += "I Marker is added!";
        }
     }
     return  Py_BuildValue("s", msg.c_str());
#line 88 "sipodsystemOdJointForce.cxx"
	}

	// Report an error if the arguments couldn't be parsed.

	sipNoMethod(sipArgsParsed,sipName_OdJointForce,sipName_set_joint);

	return NULL;
}

// Cast a pointer to a type somewhere in its superclass hierarchy.

const void *sipCast_OdJointForce(const void *ptr,PyObject *targetClass)
{
	if (targetClass == sipClass_OdJointForce)
		return ptr;

	return NULL;
}

static void sipDealloc_OdJointForce(sipThisType *sipThis)
{
	if (sipThis -> u.cppPtr != NULL)
	{

		if (sipIsPyOwned(sipThis))
		{
			Py_BEGIN_ALLOW_THREADS

			delete (OdJointForce *)sipThis -> u.cppPtr;

			Py_END_ALLOW_THREADS
		}
	}

	sipDeleteThis(sipThis);
}

PyObject *sipNew_OdJointForce(PyObject *sipSelf,PyObject *sipArgs)
{
	static sipExtraType et = {
		sipCast_OdJointForce
	};

	int sipFlags = SIP_PY_OWNED;
	int sipArgsParsed = 0;
	sipThisType *sipThis = NULL;
	OdJointForce *sipCpp = NULL;

	// See if there is something pending.

	sipCpp = (OdJointForce *)sipGetPending(&sipFlags);

	if (sipCpp == NULL)
	{
#line 749 "python\od_system.sip"
     int id;
     PyObject *pystr;
     if (sipParseArgs(&sipArgsParsed,sipArgs, "iO", &id, &pystr)) {
        char* pstr=PyString_AsString(pystr);
        Py_BEGIN_ALLOW_THREADS
        sipCpp = new OdJointForce(id, pstr);
        Py_END_ALLOW_THREADS
     }  
#line 152 "sipodsystemOdJointForce.cxx"
	}

	if (sipCpp == NULL)
	{
		OdJointForce * a0;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"J1",sipClass_OdJointForce,&a0))
		{
			Py_BEGIN_ALLOW_THREADS
			sipCpp = new OdJointForce(*a0);
			Py_END_ALLOW_THREADS
		}
	}

	if (sipCpp == NULL)
	{
		sipNoCtor(sipArgsParsed,sipName_OdJointForce);
		return NULL;
	}

	// Wrap the object.

	if ((sipThis = sipCreateThis(sipSelf,sipCpp,&sipType_OdJointForce,sipFlags,&et)) == NULL)
	{
		if (sipFlags & SIP_PY_OWNED)
		{
			Py_BEGIN_ALLOW_THREADS

			delete (OdJointForce *)sipCpp;

			Py_END_ALLOW_THREADS
		}

		return NULL;
	}

	Py_INCREF(Py_None);
	return Py_None;
}

static PyMethodDef lazyMethods_OdJointForce[] = {
	{sipName_set_expression, sipDo_OdJointForce_set_expression, METH_VARARGS, NULL},
	{sipName_set_joint, sipDo_OdJointForce_set_joint, METH_VARARGS, NULL}
};

sipLazyAttrDef sipClassAttrTab_OdJointForce = {
	0, NULL,
	sizeof (lazyMethods_OdJointForce) / sizeof (PyMethodDef), lazyMethods_OdJointForce,
	0, NULL
};

OdJointForce *sipForceConvertTo_OdJointForce(PyObject *valobj,int *iserrp)
{
	if (*iserrp || valobj == NULL)
		return NULL;

	if (valobj == Py_None || sipIsSubClassInstance(valobj,sipClass_OdJointForce))
		return (OdJointForce *)sipConvertToCpp(valobj,sipClass_OdJointForce,iserrp);

	sipBadClass(sipName_OdJointForce);

	*iserrp = 1;

	return NULL;
}
