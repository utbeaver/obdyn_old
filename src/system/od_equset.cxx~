#include "od_system.h"
#include "od_equset.h"
#include "od_gstiff.h"


od_equation::~od_equation() {
  int i;
  if(info_str.size())
    cout << info_str << " is done!" << endl;
  DELARY(pRhs) 
  if(pJac) {
    for(i=0; i<dimJac; i++) DELARY(pJac[i])
    DELARY(pJac) 
  }
  delete lin_solver; delete  pIntegrator;
  DELARY(error) DELARY(_X) DELARY(_Xdot)
}

void
od_equation::
set_lambda(double* lambda) {
  int i;
  for(i=0; i<numLoops; i++) {
    lambda=pSys->loop_list[i]->set_lambda(lambda);
  }
  for(i=0; i<numMotions; i++) {
    lambda = pSys->get_motion_via_index(i)->set_lambda(lambda);
  }
}

void
od_equation::
set_lambda_si2(double* lambda) {
  int i;
  for(i=0; i<numLoops; i++) {
    lambda=pSys->loop_list[i]->set_lambda_si2(lambda);
  }
  for(i=0; i<numMotions; i++) {
    lambda = pSys->get_motion_via_index(i)->set_lambda_si2(lambda);
  }
}

double od_equation::startRecord() {return pSys->startRecord();}
void od_equation::stopRecord(double s, int d) {pSys->stopRecord(s, d);}
double od_equation::getKPE() {return pSys->getKPE();}

int od_equation::checkEulerBryant() { return pSys->checkEulerBryant();}

ofstream* od_equation::msgFile() {return pSys->msgFile();}

double od_equation::time(double t) { 
  return pSys->time(t);
}

int
od_equation::
initialize() {
  pSys->initialize(_dva_type, _jac_type, Ana_Type);
  states = pSys->pstates();
  dstates = pSys->pdstates();
  ddstates = pSys->pddstates();
  //get the number of ndof
  tree_ndofs = pSys->TreeDofs();
  //vector<int>& releget the number of constraint
  numLoops = 
    pSys->get_num_explicit_constraints();
  numMotions = pSys->getNumMotions();
  for(int i=0; i<numLoops; i++) {
    pSys->loop_list[i]->initialize(time()>1.e-9);
  }
  return 0;
}

od_equation_disp_ic::
od_equation_disp_ic(od_system *psys):od_equation_kin_and_static(psys) {
  info_str = "Displacement Reconcilation";
  cout << info_str << " begins..." << endl;
  _dva_type = od_object::DISP;
  _jac_type = od_object::JAC_INIT_DISP;
  Ana_Type = od_object::INIT_DISP;
}

int
od_equation_kin_and_static::
initialize() {
  if(initialized) return 0;
  int i, j;
  icInt = 0;
  od_equation::initialize();
  if (pSys->get_analysis_type() == od_object::INIT_VEL) {
    for(i=0; i<pSys->num_body(); i++) {
      icInt += pSys->body_list_[i]->ifRic();
      icInt += pSys->body_list_[i]->ifTic();
    }
  }
  //allocate space for pJac
  dim_rows = numLoops*6 + tree_ndofs+numMotions;
  dimJac=dim_cols = dim_rows;
  
  pJac = new double*[dim_rows+icInt];
  for(j=0; j<dim_cols+icInt; j++) {
    pJac[j] = new double[dim_cols+icInt];
  }
  
  lin_solver = (od_linsolv*) 
    (new od_linsolv_dense(dim_rows+icInt, pJac)); 
  pRhs = new double[dim_rows+icInt];
  for(i=0; i<dim_rows+icInt; i++) {
    fill(pJac[i], pJac[i]+dim_cols+icInt, 0.0);
  }
  for(i=0; i<tree_ndofs; i++) {
    pJac[i][i] = 1.0;
  }
  error = new double[dim_rows-tree_ndofs];
  fill(error, error+dim_rows+icInt-tree_ndofs, 5.0e-16);
  return 0;
}

void od_equation_kin_and_static::
process_void_row_and_col(int ii, double val){
  for(int i=0; i< dim_rows; i++) {
    pJac[i][ii]=pJac[ii][i] = 0.0;
    pJac[ii][ii]=val;
  }
}

int
od_equation_kin_and_static::
evaluate(int eval_jac) {
  int i, ii, j, jj, base;
  int temp_int=0;
  double value;
  pSys->update(eval_jac);
  pSys->get_states();
  fill(pRhs, pRhs+dim_rows+icInt, 0.0);
  if (eval_jac) {
    for(i=0; i<dim_rows; i++) {  fill(pJac[i], pJac[i]+dim_rows, 0.0);}

    for(i=0; i<numLoops; i++) {
      pSys->loop_list[i]->evaluate(0);
      pSys->loop_list[i]->checkRedundancy();
      base = tree_ndofs + i*6;
      for(j=0; j<pSys->loop_list[i]->num_nonzero(); j++) {
        ii = pSys->loop_list[i]->row(j)+base;
        jj = pSys->loop_list[i]->col(j);
        value = pSys->loop_list[i]->jac(j);
        pJac[ii][jj] += value;
        pJac[jj][ii] += value;
      }
      for(ii=0; ii<6; ii++) {
        temp_int = base+ii;
        if (pSys->loop_list[i]->if_redundant(ii)) {
          for(jj=0; jj<tree_ndofs; jj++) {
            pJac[temp_int][jj] = 0.0;
            pJac[jj][temp_int] = 0.0;
          }
          pJac[temp_int][temp_int] = 1.0;
        }
      }
    }
    base = tree_ndofs + numLoops*6+icInt;
    for(i=0; i<numMotions; i++) {
      ii = base+i;
      jj = pSys->get_motion_via_index(i)->getIndex();
      pJac[ii][jj]=1;
      pJac[jj][ii]=1;
    }
    pSys->evaluate_rhs(pRhs);
    pSys->evaluate_Jac(pJac);
    for(i=0; i<dim_rows; i++) pRhs[i] = -pRhs[i];
  } else {
    pSys->evaluate_rhs(pRhs);
    for(i=0; i<dim_rows; i++) pRhs[i] = -pRhs[i];
    for(i=0; i<numLoops; i++) {
      pSys->loop_list[i]->evaluate(1);
    }
  }
  
  base = tree_ndofs + numLoops*6+icInt;
  for(i=0; i<numMotions; i++) {
    pRhs[base+i] = -pSys->get_motion_via_index(i)->rhs(pSys->get_dva_type(), 1);
  }
  for(i=0; i<numLoops; i++) {
    base = tree_ndofs+i*6;
    for(j=0; j<6; j++) {
      if (pSys->loop_list[i]->if_redundant(j)) {
        pRhs[base+j] = 0.0;
      } else {
        pRhs[base+j] = -pSys->loop_list[i]->rhs(j);
      }
    }
  }
  return 0;
}

int od_equation_disp_ic::
solve(double _temp) {
  int i;
  int max_rhs_row, max_var_row;
  double max_rhs, max_var;
  int num_dofs;
  int error_code = 0;
  int num_iterations = 0;
  int dofs_calculated = 0;
  for(;;) {
    max_rhs = 0.0;
    max_var = 0.0;
    pSys->set_states();
    if(pSys->Ic.disp_pattern[num_iterations%10] == 1) {
      evaluate(1);
      lin_solver->print_out();  
      lin_solver->evaluate();  
    } else {
      evaluate(0);
    }
    if (!dofs_calculated) {
      num_dofs = tree_ndofs; 
      for(i=0; i<numLoops; i++) {
        int temp_dof = pSys->loop_list[i]->num_of_redundant_constraints(); 
        num_dofs -= (6-temp_dof); 
      }
      num_dofs -= numMotions;
      pSys->set_dofs(num_dofs);
      dofs_calculated = 1;
    }
    if(!numLoops) {
      cout << "This is a system without loop. " << endl;
      cout << "Displacement Reconcilation achieved without iteration" << endl; 
      break;
    }
    
    for(i=tree_ndofs; i<dim_rows; i++) {
      if(fabs(pRhs[i]) > max_rhs) {
        max_rhs = fabs(pRhs[i]);
        max_rhs_row = i;
      }
    }
    
    if (fabs(max_rhs) <= pSys->Ic.disp_tolerance && num_iterations != 0) {
      cout << "The displacement Reconcilation is achieved after " << num_iterations << " iterations" << endl;
      cout << " with maximum residual as " << max_rhs << endl;
      cout << " The system has " << pSys->get_dofs() << " degree-of-freedom(s)." << endl;
      evaluate(0);
      pSys->Analysis_Flags.disp_ic=1;
      break;
    }
    pRhs = lin_solver->solve(pRhs, 0); 
    for(i=0; i<dim_rows; i++) {
      if(fabs(pRhs[i]) > fabs(max_var)) {
        max_var = pRhs[i];
        max_var_row = i;
      }
    }
    
    num_iterations++;
    if (num_iterations > pSys->Ic.disp_maxit) {
      evaluate(1);
      lin_solver->print_out();  
      throw equ_exception(num_iterations, max_var, max_var_row, max_rhs, max_rhs_row);
    }
    for(i=0; i<tree_ndofs; i++) {
      states[i] += pRhs[i];
    }
  }
  return error_code;
}

od_equation_vel_ic::
od_equation_vel_ic(od_system *psys):od_equation_kin_and_static(psys) {
  _dva_type = od_object::VEL;
  _jac_type = od_object::JAC_VEL;
  Ana_Type = od_object::INIT_VEL;
  info_str = "Velocity Reconcilation";
  cout << info_str << " begins..." << endl;
}

int od_equation_vel_ic::
solve(double _temp) {
  int i;
  pSys->unset_evaluated();
  evaluate(1);
  
  lin_solver->print_out();  
  
  lin_solver->evaluate();  
  pRhs = lin_solver->solve(pRhs, 0); 
  for(i=0; i<tree_ndofs; i++) {
    dstates[i] = pRhs[i];
  }
  pSys->set_states();
  pSys->Analysis_Flags.vel_ic=1;
  evaluate(0);
  return 0;
}

od_equation_acc_ic::
od_equation_acc_ic(od_system *psys):od_equation_kin_and_static(psys) {
  _dva_type = od_object::ACC;
  _jac_type = od_object::JAC_ACC;
  Ana_Type = od_object::INIT_ACC;
  info_str = "Acceleration and Force Reconcilation";
  cout << info_str << " begins..." << endl;
}


int od_equation_acc_ic::
solve(double _temp) {
  int i;
  double *pd;
  pSys->unset_evaluated();
  evaluate(1);
  
  lin_solver->print_out();  
  lin_solver->evaluate();  
  
  pRhs = lin_solver->solve(pRhs, 0); 
  copy(pRhs, pRhs+tree_ndofs, ddstates);
  
  pd = pRhs+tree_ndofs;
  for(i=0; i<numLoops; i++) {
    pd=pSys->loop_list[i]->set_lambda(pd);
  }
  for(i=0; i<numMotions; i++) {
    pd=pSys->get_motion_via_index(i)->set_lambda(pd);
  }
  pSys->set_states();
  pSys->Analysis_Flags.acc_ic=1;
  evaluate(0);
  
  
  return 1;
}



od_equation_kinematic::
od_equation_kinematic(od_system *psys, double end_time, int steps) 
: od_equation_kin_and_static(psys) {
  _end_time = end_time;
  _steps = steps;
  if(_steps <= 0) _steps = 1;
  Ana_Type = od_object::KINEMATIC;
  //pSys->set_analysis_type(od_object::KINEMATIC);
  eval = 1;
  //cout << "Displacement Reconcilation begins..." << endl;
}

int 
od_equation_kinematic::
initialize() {
  if(pSys->get_dofs() != 0) {
    cout << "This system has " << pSys->get_dofs() << " degrees of freedom." << endl;
    return 1;
  }
  eval = 1;
  if(initialized) return 0;
  od_equation_kin_and_static::initialize();
  initialized=1; 
  return 0;
}


int 
od_equation_kinematic::
solve_for_disp(){
  int i, fail_num;
  int max_rhs_row, max_var_row;
  double max_rhs, max_var;
  int error_code = 0;
  int num_iterations = 0;
  pSys->set_analysis_type(od_object::INIT_DISP);
  pSys->set_dva_type(od_object::DISP);
  pSys->set_jac_type(od_object::JAC_DISP);
  max_rhs = 0.0;
  max_var = 0.0;
  fail_num = 0;
  eval = 1;
  pSys->unset_evaluated();
  pSys->get_states();
  for(;;) {
    max_rhs = 0.0;
    max_var = 0.0;
    pSys->set_states();
    if(pSys->kinematics.disp_pattern[num_iterations%10] == 1) {
      if (eval) {
        evaluate(eval);
        lin_solver->evaluate();
        eval = 0;
      } else {
        evaluate(0);
      }
    } else {
      evaluate(0);
    }
    if(!numLoops) {
      break;
    }
    for(i=tree_ndofs; i<dim_rows; i++) {
      if(fabs(pRhs[i]) > max_rhs) {
        max_rhs = fabs(pRhs[i]);
        max_rhs_row = i;
      }
    }
    if (fabs(max_rhs) <= pSys->kinematics.disp_tolerance) {
      break;
    }
    pRhs = lin_solver->solve(pRhs, 0); 
    for(i=0; i<dim_rows; i++) {
      if(fabs(pRhs[i]) > fabs(max_var)) {
        max_var = pRhs[i];
        max_var_row = i;
      }
    }
    
    num_iterations++;
    if (num_iterations > pSys->kinematics.disp_maxit) {
      if (fail_num > 5) {
        cout << " The reconcilation fails with " 
          << fail_num << " tries " << "at time " 
          << pSys->time()<<endl; 
        error_code = 1;
        evaluate(1);
        lin_solver->print_out();  
        throw equ_exception(num_iterations, max_var, max_var_row, max_rhs,  max_rhs_row, pSys->time());
      }
      num_iterations=0;
      fail_num++;
      eval = 1;
    }
    /*if eval is needed, do not update the state which causes the failure*/
    if (eval != 1) {
      for(i=0; i<tree_ndofs; i++) {
        states[i] += pRhs[i];
      }
    }
  }
  return error_code;
}

int
od_equation_kinematic::
solve_for_vel() {
  int i;
  pSys->unset_evaluated();
  pSys->set_analysis_type(od_object::INIT_VEL);
  pSys->set_dva_type(od_object::VEL);
  pSys->set_jac_type(od_object::JAC_VEL);
  pSys->get_states();
  evaluate(1);
//  lin_solver->print_out();
  lin_solver->evaluate();  
  pRhs = lin_solver->solve(pRhs, 0); 
  for(i=0; i<tree_ndofs; i++) {
    dstates[i] = pRhs[i];
  }
  pSys->set_states();
  pSys->Analysis_Flags.vel_ic=1;
  evaluate(0);
  return 0;
}

int od_equation_kinematic::
solve_for_acc_force() {
  int i;
  double *pd;
  pSys->set_analysis_type(od_object::INIT_ACC);
  pSys->set_dva_type(od_object::ACC);
  pSys->set_jac_type(od_object::JAC_ACC);
  pSys->unset_evaluated();
  pSys->get_states();
  evaluate(1);
  
  lin_solver->evaluate();  
  
  pRhs = lin_solver->solve(pRhs, 0); 
  for(i=0; i<tree_ndofs; i++) {
    ddstates[i] = pRhs[i];
  }
  pd = pRhs+tree_ndofs;
  for(i=0; i<numLoops; i++) {
    pd=pSys->loop_list[i]->set_lambda(pd);
  }
  for(i=0; i<numMotions; i++) {
    pd=pSys->get_motion_via_index(i)->set_lambda(pd);
  }
  pSys->set_states();
  pSys->Analysis_Flags.acc_ic=1;
  evaluate(0);
  
  return 0;
}

int 
od_equation_kinematic::
solve(double _temp) {
  int i,j;
  double start_time = pSys->time();
  double delta = (_end_time-start_time)/(double)_steps;
  if (delta < 0.0) return 0;
  double time = 0.0;
  int error_code = 0;
  if (_end_time < 1.0e-17) return error_code;
  for(i=0; i<_steps; i++) {
    time = start_time+(double)(i+1)*delta;
    pSys->time(time);
    //prediction
    for(j=0; j<tree_ndofs; j++) {
      states[j] += dstates[j]*delta;
    }
    //solve for disp
    
    error_code = solve_for_disp();
    if(error_code) break;
    //solve for vel
    
    error_code = solve_for_vel();
    if(error_code) break;
    
    //solve for acc and force
    error_code = solve_for_acc_force();
    if(error_code) break;
    
  }
  return error_code;
}

void od_equation_kinematic::simulate(double toTime) {
  _end_time = toTime;
  this->solve();
}

od_equation_static::
od_equation_static(od_system *psys, int steps, double  err_tol) 
: od_equation_kin_and_static(psys) {
  Ana_Type = od_object::STATIC;
  //pSys->set_analysis_type(od_object::STATIC);
  _dva_type = od_object::DISP;
  //pSys->set_dva_type(od_object::DISP);
  _jac_type = od_object::JAC_STATIC;
  //pSys->set_jac_type(od_object::JAC_STATIC);
  info_str = "Static Analysis";
  cout << info_str << " begins..." << endl;
  _tol = err_tol;
  _steps = steps;
  if(_steps <= 0) _steps = 1;
  eval = 1;
}

int
od_equation_static::
initialize() {
  eval = 1;
  if(initialized) return 0;
  od_equation_kin_and_static::initialize();
  return 0;
}



int
od_equation_static::
solve(double _temp) {
  int i, ii;
  int num_dofs;
  int max_rhs_row, max_var_row;
  double max_rhs, max_var;
  int dofs_calculated = 0;
  int converged = 0;
  int void_row;
  int last_row=-1;
  removed_entries.resize(0);
  for(ii=0; ii<_steps; ii++) {
    pSys->set_states();
    evaluate(1);
    do {
      lin_solver->print_out();  
      void_row=lin_solver->evaluate();
      if(void_row) { 
        if( void_row != last_row) {
          states[void_row-1] += .01;//pRhs[void_row-1]/36000.0;
          pSys->set_states();
          evaluate(1);       
          last_row = void_row;
        } else {
          evaluate(1);
          removed_entries.push_back(void_row);
          for(i=0; i<(int)removed_entries.size(); i++) {
            process_void_row_and_col(removed_entries[i]-1, 1.0e+17);
          }
        }
      }
    } while( void_row != 0);
    
    max_rhs = 0.0;
    max_var = 0.0;
    if (!dofs_calculated) {
      num_dofs = tree_ndofs; 
      for(i=0; i<numLoops; i++) {
        int temp_dof = pSys->loop_list[i]->num_of_redundant_constraints(); 
        num_dofs -= (6-temp_dof); 
      }
      num_dofs -= numMotions;
      pSys->set_dofs(num_dofs);
      dofs_calculated = 1;
    }
    if (num_dofs == 0) {
      cout << "This system has no degrees_of_freedom. Static analysis is aborted\n" << endl;
      break;
    }
    for(i=0; i<tree_ndofs; i++) {
      if(fabs(pRhs[i]) > max_rhs) {
        max_rhs = fabs(pRhs[i]);
        max_rhs_row = i;
      }
    }
    pRhs = lin_solver->solve(pRhs, 0); 
    for(i=0; i<dim_rows+icInt; i++) {
      if(fabs(pRhs[i]) > fabs(max_var)) {
        max_var = fabs(pRhs[i]);
        max_var_row = i;
      }
    }
    double d30 = 3.1415926/6.0;
    for(i=0; i<tree_ndofs; i++) {
      if (fabs(max_var) > d30) pRhs[i] *= d30/fabs(max_var);
      states[i] += pRhs[i];
    }
    set_lambda(pRhs+tree_ndofs);
    if(fabs(max_var) < _tol ) {
      converged = 1;
      break;
    }
  }
  if( converged == 0) {
    evaluate(1);
    throw equ_exception(_steps, max_var, max_var_row, max_rhs, max_rhs_row);
  }
  return 0;
}

od_equation_dynamic::od_equation_dynamic(od_system *psys, double end, int steps, double tol) : od_equation(psys) {
  _end = end; _steps = steps; _tol = tol;
  Ana_Type = od_object::DYNAMIC;
  _dva_type = od_object::DISP_VEL_ACC;
  _jac_type = od_object::JAC_DYNAMIC;
  //pSys->set_analysis_type(od_object::DYNAMIC);
  //pSys->set_dva_type(od_object::DISP_VEL_ACC);
  //pSys->set_jac_type(od_object::JAC_DYNAMIC);
  varPermu=0;
}

od_equation_dynamic::~od_equation_dynamic() {
  DELARY(varPermu)  DELARY(Vars)
}

int od_equation_dynamic::initialize() {
  if (initialized) return 0;
  int j, base;
  pSys->init_dynamics();
  od_equation::initialize();
  //allocate space for pJac
  dim_cols=dim_rows = 2*(numLoops*6 + tree_ndofs+numMotions); 
  Vars=new int[dim_rows]; 
  for(j=0; j<dim_rows; j++) Vars[j]=0;
  for(j=0; j<numLoops; j++) 
  {
    int k;
    base = 2*tree_ndofs+6*j;
    for(k=0; k<6; k++) Vars[base+k]=2;
    base += numLoops*6;
    for(k=0; k<6; k++) Vars[base+k]=1;
  }
  for(j=0; j<numMotions; j++) {
    base = 2*tree_ndofs+6*numLoops+j;
    Vars[base] = 2;
    base += 6*numLoops+numMotions;
    Vars[base] = 1;
  }
  _X = new double[dim_rows];
  _Xdot = new double[dim_rows];
  fill(_X, _X+dim_rows, 0.0);
  fill(_Xdot, _Xdot+dim_rows, 0.0);
  
  pIntegrator = new od_gstiff(this, 1.0e-3);
  initialized=1; 
  pSys->getKPE();
  return 0;
}

int od_equation_dynamic::checkRedundancy(){
  int flag=0;
  for(int i=0; i<numLoops; i++) {
    flag += pSys->loop_list[i]->checkRedundancy();
    if(flag) return 1;
  }
  return 0;  
}

void od_equation_dynamic::set_states() {
  int i;
  int intTemp = tree_ndofs*sizeof(double);
  memcpy(dstates, _X, intTemp); //V
  memcpy(states, _X+tree_ndofs, intTemp); //U
  memcpy(ddstates, _Xdot, intTemp);  //Vdot
  pSys->set_states();
  for(i=0; i<numLoops; i++) {
    od_loop* loop=pSys->loop_list[i];
    loop->set_lambda_si2(_X+tree_ndofs*2+6*i, 0);
    loop->set_lambda(_X+tree_ndofs*2+numMotions+6*(i+numLoops), 0);
  }  
  for(i=0; i<numMotions; i++) {
    od_motion* motion=pSys->get_motion_via_index(i);
    motion->set_lambda_si2(_X+tree_ndofs*2+6*numLoops+i, 0);
    motion->set_lambda(_X+tree_ndofs*2+12*numLoops+numMotions+i, 0);
  }  
}

void od_equation_dynamic::get_states() {
  int i;
  int intTemp = tree_ndofs*sizeof(double);
  double *pf, *pm, *pd;
  pSys->get_states();
  memcpy(_X, dstates, intTemp); 
  memcpy(_X+tree_ndofs, states,  intTemp); 
  memcpy(_Xdot, ddstates, intTemp);
  memcpy(_Xdot+tree_ndofs, dstates, intTemp);
  for(i=0; i<numLoops; i++) {
    od_loop* loop=pSys->loop_list[i];
    pf = loop->force_si2();
    pm = loop->moment_si2(); pd =_X+tree_ndofs*2+6*i; EQ3(pd, pm) pd+=3; EQ3(pd, pf)      
    pf = loop->force();
    pm = loop->moment(); 
    pd = _X+tree_ndofs*2+numMotions+6*(numLoops+i);
    EQ3(pd, pm) pd+=3; EQ3(pd, pf)
  }
  for(i=0; i<numMotions; i++) {
    od_motion* motion=pSys->get_motion_via_index(i);
    _X[tree_ndofs*2+6*numLoops+i]=motion->get_lambda_si2();
    _X[tree_ndofs*2+12*numLoops+numMotions+i]=motion->get_lambda();
  }
}

void od_equation_dynamic::numDif(ofstream* pf, string& idxName) {
  int i,j;
  double delta = 1.0e-6;
  double invDelta = .5/delta;
  double* lRhs=new double[dim_rows];
  double* pNumJac=new double[dim_rows*dim_rows];
  Vec3* lOmega = new Vec3[tree_ndofs];
  Vec3* lOmegaDot = new Vec3[tree_ndofs];
  Vec3* lVel = new Vec3[tree_ndofs];
  Vec3* lAcc = new Vec3[tree_ndofs];
  Vec3* wVec = new Vec3[tree_ndofs];
  od_jacobian<Vec3> parVel_parq;
  od_jacobian<Vec3> parVel_parq_dot; 
  od_jacobian<Vec3> parVel_dot_parq;
  od_jacobian<Vec3> parVel_dot_parq_dot;  
  
  od_jacobian<Vec3> parOmega_parq;
  od_jacobian<Vec3> parOmega_parq_dot; //JR;
  od_jacobian<Vec3> parOmega_dot_parq;
  od_jacobian<Vec3> parOmega_dot_parq_dot; //parOmega_parq
  parVel_parq.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel2);
  parVel_parq_dot.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel2);
  parVel_dot_parq.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel2);
  parVel_dot_parq_dot.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel2);
  
  
  parOmega_parq.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel3);
  parOmega_parq_dot.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel3);
  parOmega_dot_parq.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel3);
  parOmega_dot_parq_dot.create_jacobian(pSys->num_body(), tree_ndofs, pSys->relevenceLevel3);
  
  
  for(j=0; j<dim_cols; j++) {
    double tempD = _X[j];
    double tempDot = _Xdot[j];
    _X[j] = tempD-delta; _Xdot[j]=tempDot-delta;
    evalRhs();
    for(i=0; i<dim_rows; i++) lRhs[i] = pRhs[i];
    _X[j] = tempD+delta; _Xdot[j]=tempDot+delta; 
    evalRhs();
    for(i=0; i<dim_rows; i++) 
      pNumJac[i*dim_cols+j] = -(pRhs[i]-lRhs[i])*invDelta;
    _X[j] = tempD; _Xdot[j]=tempDot; set_states();
  }
  string tempStr = "NumJac";/* tempStr+=idxName;*/ tempStr += "=["; *pf << tempStr<<endl;
  for(i=tree_ndofs; i<dim_rows; i++) {
    for(j=0; j<dim_cols; j++) {
      *pf << scientific << setprecision(8);
      if(fabs(pNumJac[i*dim_cols+j]) < 1.0e-6) pNumJac[i*dim_cols+j]=0.0;
      *pf << setw(10)<< pNumJac[i*dim_cols+j] << " ";
    }
    *pf << ";"<<endl;
  }
  *pf << "];" << endl;
  tempStr="JacDif"; tempStr+=idxName;
  *pf << tempStr << "=Jac-NumJac" << endl << endl;;
  DELARY(lRhs) DELARY(pNumJac)
  Vec3 *pV;
  //wrt to q
  int intTemp=(dim_cols-numLoops*12)/2;
  for(j=0; j<intTemp;j++) {
    double tempD = _X[j+intTemp];
    _X[j+intTemp] = tempD-delta; 
    evalRhs();
    lVel = pSys->getVel(lVel);
    lAcc = pSys->getVelDot(lAcc);
    lOmega = pSys->getOmega(lOmega);
    lOmegaDot = pSys->getOmegaDot(lOmegaDot);
    _X[j+intTemp] = tempD+delta; 
    evalRhs();
    wVec = pSys->getVel(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lVel[i] -= wVec[i];
      lVel[i].multiplied_by(-invDelta);
      
      pV = parVel_parq.element(i,j);
      if(pV) *pV = lVel[i];
      
    }
    wVec = pSys->getVelDot(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lAcc[i] -= wVec[i];
      lAcc[i].multiplied_by(-invDelta);
      
      pV = parVel_dot_parq.element(i,j);
      if(pV) *pV = lAcc[i];
      
    }
    wVec = pSys->getOmega(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lOmega[i] -= wVec[i];
      lOmega[i].multiplied_by(-invDelta);
      
      pV = parOmega_parq.element(i,j);
      if(pV) *pV = lOmega[i];
      
    }
    wVec = pSys->getOmegaDot(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lOmegaDot[i] -= wVec[i];
      lOmegaDot[i].multiplied_by(-invDelta);
      
      pV = parOmega_dot_parq.element(i,j);
      if(pV) *pV = lOmegaDot[i];
      
    }
    _X[j+intTemp] = tempD; set_states();
  }
  //wrt to q_dot
  for(j=0; j<intTemp;j++) {
    double tempD = _X[j];
    _X[j] = tempD-delta; set_states(); evalRhs();
    lVel = pSys->getVel(lVel);
    lAcc = pSys->getVelDot(lAcc);
    lOmega = pSys->getOmega(lOmega);
    lOmegaDot = pSys->getOmegaDot(lOmegaDot);
    _X[j] = tempD+delta; set_states(); evalRhs();
    wVec = pSys->getVel(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lVel[i] -= wVec[i];
      lVel[i].multiplied_by(-invDelta);
      
      pV = parVel_parq_dot.element(i,j);
      if(pV) *pV = lVel[i];
      
    }
    wVec = pSys->getVelDot(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lAcc[i] -= wVec[i];
      lAcc[i].multiplied_by(-invDelta);
      
      pV = parVel_dot_parq_dot.element(i,j);
      if(pV) *pV = lAcc[i];
      
    }
    wVec = pSys->getOmega(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lOmega[i] -= wVec[i];
      lOmega[i].multiplied_by(-invDelta);
      
      pV = parOmega_parq_dot.element(i,j);
      if(pV) *pV = lOmega[i];
      
    }
    wVec = pSys->getOmegaDot(wVec);
    for(i=0; i<pSys->num_body(); i++) {
      lOmegaDot[i] -= wVec[i];
      lOmegaDot[i].multiplied_by(-invDelta);
      
      pV = parOmega_dot_parq_dot.element(i,j);
      if(pV) *pV = lOmegaDot[i];
      
    }
    _X[j] = tempD; set_states();
  }
  //To files
  string name_;
  if(compare_Jac(parOmega_parq, pSys->parOmega_parq)) {
    name_ = "num_parOmega_parq"; parOmega_parq.toFile(pf, name_.c_str());
    name_ = "parOmega_parq"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  if(compare_Jac(parOmega_parq_dot, pSys->JR)) {
    name_ = "num_parOmega_parq_dot"; parOmega_parq_dot.toFile(pf, name_.c_str());
    name_ = "parOmega_parq_dot"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  if(compare_Jac(parOmega_dot_parq, pSys->parOmega_dot_parq)) {
    name_ = "num_parOmega_dot_parq"; parOmega_dot_parq.toFile(pf, name_.c_str());
    name_ = "parOmega_dot_parq"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  if(compare_Jac(parOmega_dot_parq_dot, pSys->parOmega_dot_parq_dot)) {
    name_ = "num_parOmega_dot_parq_dot"; parOmega_dot_parq_dot.toFile(pf, name_.c_str());
    name_ = "parOmega_dot_parq_dot"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  if(compare_Jac(parVel_parq, pSys->parVel_parqG)) {
    name_ = "num_parVel_parq"; parVel_parq.toFile(pf, name_.c_str());
    name_ = "parVel_parq"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  if(compare_Jac(parVel_parq_dot, pSys->parVel_parq_dotG)) {  
    name_ = "num_parVel_parq_dot"; parVel_parq_dot.toFile(pf, name_.c_str());
    name_ = "parVel_parq_dot"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  if(compare_Jac(parVel_dot_parq, pSys->parVel_dot_parqG)) {
    name_ = "num_parVel_dot_parq"; parVel_dot_parq.toFile(pf, name_.c_str());
    name_ = "parVel_dot_parq"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  if(compare_Jac(parVel_dot_parq_dot, pSys->parVel_dot_parq_dotG)) {
    name_ = "num_parVel_dot_parq_dot"; parVel_dot_parq_dot.toFile(pf, name_.c_str());
    name_ = "parVel_dot_parq_dot"; pSys->toFile(pf, name_); *pf <<"%%%%%%%%%%%%%%%%%%%%" << endl;
  }
  DELARY(lOmega) DELARY(lOmegaDot) DELARY(lVel) DELARY(lAcc) DELARY(wVec)
}

//void od_equation_dynamic::setEnd(double end) {_end = end; } 
void od_equation_dynamic::setSteps(int steps) {_steps = steps; }
void od_equation_dynamic::setMinStep(double val) { hMin = val;} 
void od_equation_dynamic::setMaxStep(double val) { hMax = val;} 
void od_equation_dynamic::setInitStep(double val) { _initStep = val;} 
void od_equation_dynamic::setLocalErrorTol(double val) { _tol = val;} 
void od_equation_dynamic::setMaxCorrectNum(int val) { _corrNum = val;} 

void od_equation_dynamic::simulate(double end_time, int debug_) {
  int i=0;
  double expectedTime=0;
  double _delta;
  _end = end_time;
  _steps=1;
  expectedTime = pSys->time();
  _delta = _end/(double)_steps;
  _delta = (_end-expectedTime)/(double)_steps;
  _debug = debug_;
  if (expectedTime < 1.0e-15) {
    pIntegrator->setMinStep(hMin);
    pIntegrator->setMaxStep(hMax);
    pIntegrator->setInitStep(_initStep);
    pIntegrator->setLocalErrTol(_tol);
    pIntegrator->setMaxCorrectNum(_corrNum);
  }
  
  for(i=0; i<_steps; i++) {
    expectedTime += _delta; 
 //   double s =pSys->startRecord();
    int errorCode=pIntegrator->toTime(expectedTime);
 //   pSys->stopRecord(s, 2);
    if(errorCode) {
      throw equ_exception(0, 0.0, 0, 0.0, 0, pSys->time());
    }
  }
  pIntegrator->output(expectedTime);
  pSys->update();
}

od_equation_bdf_I::od_equation_bdf_I(od_system *psys, double end, int steps, double tol) 
: od_equation_dynamic(psys, end, steps, tol) {
  reEval = 1;
  pIntegrator = 0;
}

int od_equation_bdf_I::initialize() {
  int i, j, ii, base;
  od_equation_dynamic::initialize();
  dimJac = dim_rows;
  pJac = new double*[dim_rows];
  for(j=0; j<dim_cols; j++) {
    pJac[j] = new double[dim_cols];
  }
  
  pRhs = new double[dim_rows];
  varPermu=new int[dim_cols];
  int tempInt=0;
  for(j=0; j<2*tree_ndofs; j++) {
    varPermu[tempInt++]=j;    
  }
  for(i=0; i<numLoops; i++) {
    base = 2*tree_ndofs+6*i;
    for(ii=0; ii<6; ii++) 
      if(pSys->loop_list[i]->if_redundant(ii)==0) 
        varPermu[tempInt++]=base+ii;
  }
  for(i=0; i<numMotions; i++) {
    base = 2*tree_ndofs+6*numLoops;
    varPermu[tempInt++]=base+i;
  }
  for(i=0; i<numLoops; i++) {
    base = 2*tree_ndofs+6*numLoops+numMotions+6*i;
    for(ii=0; ii<6; ii++) 
      if(pSys->loop_list[i]->if_redundant(ii)==0) 
        varPermu[tempInt++]=base+ii;
  }
  for(i=0; i<numMotions; i++) {
    base = 2*tree_ndofs+12*numLoops+numMotions;
    varPermu[tempInt++]=base+i;
  }
  //lin_solver = (od_linsolv*) (new od_linsolv_dense(tempInt, pJac, varPermu)); 
  lin_solver = (od_linsolv*) (new od_linsolv_dense(dim_rows, pJac)); 
  return 1;
}



int od_equation_bdf_I::solve(double tinu) {
  double s=pSys->startRecord();
  int errorCode = 0;
  if (reEval) {
 //   lin_solver->print_out();
    errorCode = lin_solver->evaluate();
    reEval = 0;
    if(errorCode) return errorCode;
  }
  int i;
  int intTemp=2*tree_ndofs;
  //scaling the diff rhs because the the Jac scaling
  for( i=0; i<intTemp; i++) {
    pRhs[i] /= tinu;
  }
  pRhs = lin_solver->solve(pRhs, reEval);
  for( i=intTemp; i<dim_cols; i++) {
    pRhs[i] *= tinu;
  }
//  pSys->stopRecord(s,2);
  return errorCode;
}

double* od_equation_dynamic::evalRhs() {
  int i, j, base;
  int intTemp=2*tree_ndofs;
  fill(pRhs, pRhs+dim_rows, 0.0);
  set_states();
  pSys->update();
  pSys->evaluate_rhs(pRhs+tree_ndofs);
  for(i=tree_ndofs; i<intTemp; i++) {
    pRhs[i-tree_ndofs] += _X[i-tree_ndofs]-_Xdot[i]; //V - Udot
  }
  for(i=0; i<numLoops; i++) {
    base = intTemp+(i+numLoops)*6; 
    pSys->loop_list[i]->evaluate(1);
    for(j=0; j<6; j++) {
      if (pSys->loop_list[i]->if_redundant(j)) {
        pRhs[base+j] = 0.0;
      } else {
        pRhs[base+j] = -pSys->loop_list[i]->rhs(j);
      }
    }
  }
  for(i=0; i<numMotions; i++) {
    base = intTemp+numLoops*12+numMotions; 
    pRhs[base+i] = -pSys->get_motion_via_index(i)->rhs(od_object::DISP);
  }
  for(i=0; i<numLoops; i++) {
    base = intTemp+i*6; 
    for(j=0; j<6; j++) {
      if (pSys->loop_list[i]->if_redundant(j)) {
        pRhs[base+j] = 0.0;
      } else {
        pRhs[base+j] = -pSys->loop_list[i]->velRhs(j);
      }
    }
  }
  for(i=0; i<numMotions; i++) {
    base = intTemp+numLoops*6; 
    pRhs[base+i] = -pSys->get_motion_via_index(i)->rhs(od_object::VEL);
  }
  //add lambda to pRhs
  for(i=0; i<numMotions; i++) {
    int idx = pSys->get_motion_via_index(i)->getIndex();
    double val = pSys->get_motion_via_index(i)->get_lambda();
    pRhs[tree_ndofs+idx] -= val;
  }
  for(i=0; i<intTemp; i++) pRhs[i] = -pRhs[i];
  return pRhs;
}


void od_equation_bdf_I::evalJac(double tinu, int __debug) {
  double** pM;
  double minusOne = -1.0;
  double **tempJac=0;
  int i, j, base, ii, jj, baseV;
  double value, valueV;
  double s=pSys->startRecord();
  pSys->updateQ();
  pSys->updatePartials();
  if(__debug) {
    tempJac = new double*[dim_rows]; for(i=0; i<dim_rows; i++) tempJac[i] = new double[dim_cols];
    for(i=0; i<dim_rows; i++) fill(tempJac[i], tempJac[i]+dim_cols, 0.0);
  }
  //clear the Jacobian
  for(i=0; i<dim_rows; i++) fill(pJac[i], pJac[i]+dim_cols, 0.0);
  pM = new double*[tree_ndofs];
  for(i=0; i<tree_ndofs; i++) {
    pM[i] = new double[tree_ndofs]; fill(pM[i], pM[i]+tree_ndofs, 0.0);
  }
  //get M
  pSys->getM(pM);
  for(i=0; i<tree_ndofs; i++) {  
    for(j=0; j<tree_ndofs; j++) {
      pJac[i+tree_ndofs][j] = pM[i][j]*minusOne; if (tempJac) tempJac[i+tree_ndofs][j]=-pM[i][j];
    }
  }
  for(i=0; i<tree_ndofs; i++)  { 
    pJac[i][i+tree_ndofs] = minusOne; 
    pJac[i][i] = 1.0/tinu;  
    if(tempJac) { tempJac[i][i+tree_ndofs] = -1; tempJac[i][i] = 1.0;}  
  }
  //get parF_parq_dot
  for(i=0; i<tree_ndofs; i++) fill(pM[i], pM[i]+tree_ndofs, 0.0);
  pSys->parF_parq_dot(pM);
  for(i=0; i<tree_ndofs; i++) {  
    for(j=0; j<tree_ndofs; j++) { 
      pJac[i+tree_ndofs][j] += pM[i][j]/tinu; if(tempJac) tempJac[i+tree_ndofs][j] += pM[i][j];
    }
  }
  //get parF_parq
  for(i=0; i<tree_ndofs; i++) fill(pM[i], pM[i]+tree_ndofs, 0.0);
  pSys->parF_parq(pM);
  for(i=0; i<tree_ndofs; i++) {  
    for(j=0; j<tree_ndofs; j++) {
      pJac[i+tree_ndofs][j+tree_ndofs] += pM[i][j]/tinu; if(tempJac) tempJac[i+tree_ndofs][j+tree_ndofs]+=pM[i][j];
    }
  }
  //get parSi2_parq
  if(numLoops>0) {
    for(i=0; i<tree_ndofs; i++) fill(pM[i], pM[i]+tree_ndofs, 0.0);
    pSys->parSi2_parq(pM);
    for(i=0; i<tree_ndofs; i++) {  
      for(j=0; j<tree_ndofs; j++) {
        pJac[i][j+tree_ndofs] += pM[i][j]; if(tempJac) tempJac[i][j+tree_ndofs]+=pM[i][j];
      }
    }
  }
  for(i=0; i<tree_ndofs; i++) DELARY(pM[i]) 
  for(i=0; i<numLoops;i++) {
    base = 2*tree_ndofs;
    baseV = base+numLoops*6+numMotions;
    for(j=0; j<pSys->loop_list[i]->num_nonzero(); j++) {
      ii = pSys->loop_list[i]->row(j)+base+i*6;
      jj = pSys->loop_list[i]->col(j);
      value = pSys->loop_list[i]->jac(j);
      valueV = pSys->loop_list[i]->jacV(j);
      pJac[ii][jj] += value; if(tempJac) tempJac[ii][jj] += value;//parV_parq_dot
      pJac[jj][ii] += value; if(tempJac) tempJac[jj][ii] += value;//parV_parq_dot^T
      pJac[ii][jj+tree_ndofs] += valueV; if(tempJac) tempJac[ii][jj+tree_ndofs] += valueV; //parV_parq
      ii = pSys->loop_list[i]->row(j)+baseV+i*6;
      jj = pSys->loop_list[i]->col(j)+tree_ndofs;
      pJac[ii][jj] += value; if(tempJac) tempJac[ii][jj] += value;//parV_parq_dot
      pJac[jj][ii] -= value; if(tempJac) tempJac[jj][ii] -= value;//parV_parq_dot^t
    }
    for(ii=0; ii<6; ii++) {
      if (pSys->loop_list[i]->if_redundant(ii)) {
        for(jj=0; jj<tree_ndofs; jj++) {
          pJac[base+i*6+ii][jj]=0.0; if(tempJac) tempJac[base+i*6+ii][jj]=0.0;
          pJac[jj][base+i*6+ii]=0.0;if(tempJac) tempJac[jj][base+i*6+ii]=0.0;
          pJac[base+i*6+ii][jj+tree_ndofs]=0.0;if(tempJac) tempJac[base+i*6+ii][jj+tree_ndofs]=0.0;
          pJac[baseV+i*6+ii][jj+tree_ndofs]=0.0;if(tempJac) tempJac[baseV+i*6+ii][jj+tree_ndofs]=0.0;
          pJac[jj+tree_ndofs][baseV+i*6+ii]=0.0;if(tempJac) tempJac[jj+tree_ndofs][baseV+i*6+ii]=0.0;
        }
        pJac[base+i*6+ii][base+i*6+ii]=1.0;//if(tempJac) tempJac[base+i*6+ii][base+i*6+ii]=1.0;
        pJac[baseV+i*6+ii][baseV+i*6+ii]=1.0;//if(tempJac) tempJac[baseV+i*6+ii][baseV+i*6+ii]=1.0;
      }
    }
  }
  for(i=0; i<numMotions;i++) {
    base = 2*tree_ndofs+6*numLoops;
    baseV = base+numLoops*6+numMotions;
    ii = base+i;
    jj = pSys->get_motion_via_index(i)->getIndex();
    pJac[ii][jj] += 1.0; if(tempJac) tempJac[ii][jj] += 1.0;//parV_parq_dot
    pJac[jj][ii] += 1.0; if(tempJac) tempJac[jj][ii] += 1.0;//parV_parq_dot^T
    ii = baseV+i;
    jj = pSys->get_motion_via_index(i)->getIndex()+tree_ndofs;
    pJac[ii][jj] += 1.0; if(tempJac) tempJac[ii][jj] += 1.0;//parV_parq_dot
    pJac[jj][ii] -= 1.0; if(tempJac) tempJac[jj][ii] -= 1.0;//parV_parq_dot^t
  }
  reEval = 1;
  if(_debug) {
    ostringstream ost;
    ost << __debug%10;
    ofstream* pf = pSys->outFile(_debug);
    string tempStr="Jac"; tempStr += "=["; *pf << tempStr << endl;
    double tempdou=0.0;
    for(i=tree_ndofs; i<dim_rows; i++) {
      for(j=0; j<dim_cols; j++) {
        *pf << scientific << setprecision(8);
        tempdou = (fabs(tempJac[i][j]) > 1.0e-10) ? tempJac[i][j] : 0.0;
        *pf << setw(10) << tempdou << " ";
      }
      *pf << ";" <<endl;
    }
    *pf << "];" << endl;
    numDif(pf, ost.str());
    for(i=0; i<dim_rows; i++) DELARY(tempJac[i]) DELARY(tempJac)
  }
  pSys->stopRecord(s,1);
  return;
}

od_equation_bdf_II::od_equation_bdf_II(od_system *psys, double end, int steps, double tol) 
: od_equation_dynamic(psys, end, steps, tol) {
  reEval = 1;
  pIntegrator = 0;
  Fa = Fv = Jt = 0;
}

od_equation_bdf_II::~od_equation_bdf_II() {
  int i;
  if(Fa) {
    for(i=0; i<tree_ndofs; i++) DELARY(Fa[i])
    DELARY(Fa) 
  }
  if(Fv) {
    for(i=0; i<tree_ndofs; i++) DELARY(Fv[i])
    DELARY(Fv)
  }
  if(Jt) {
    for(i=0; i<6*numLoops+numMotions; i++) DELARY(Jt[i])
    DELARY(Jt)
  }
}

int od_equation_bdf_II::initialize() {
  int i, j,  ii, base;
  int tempInt=0;
  od_equation_dynamic::initialize();
  dimJac = dim_cols-tree_ndofs;
  pJac = new double*[dimJac];
  for(j=0; j<dimJac; j++) pJac[j] = new double[dimJac];
  pRhs = new double[dim_rows];
  Fa = new double*[tree_ndofs];
  Fv = new double*[tree_ndofs];
  varPermu=new int[dim_cols];
  for(j=0; j<tree_ndofs; j++){
    Fa[j] = new double[tree_ndofs];
    Fv[j] = new double[tree_ndofs];
  }
  if(numLoops || numMotions) {
    Jt = new double*[6*numLoops+numMotions];
    for(j=0; j<6*numLoops+numMotions; j++) Jt[j] = new double[tree_ndofs];
  }
  for(j=0; j<tree_ndofs; j++) varPermu[tempInt++]=j;
  for(i=0; i<numLoops; i++) {
    base = tree_ndofs+6*i;
    for(ii=0; ii<6; ii++) 
      if (pSys->loop_list[i]->if_redundant(ii)==0) 
        varPermu[tempInt++]=base+ii;
  }
  for(i=0; i<numMotions; i++) {
    base = tree_ndofs+6*numLoops;
    varPermu[tempInt++]=base+i;
  }
  for(i=0; i<numLoops; i++) {
    base = tree_ndofs+6*numLoops+numMotions+6*i;
    for(ii=0; ii<6; ii++) 
      if (pSys->loop_list[i]->if_redundant(ii)==0) 
        varPermu[tempInt++]=base+ii;
  }
  for(i=0; i<numMotions; i++) {
    base = tree_ndofs+12*numLoops+numMotions;
    varPermu[tempInt++]=base+i;
  }
  lin_solver = (od_linsolv*) (new od_linsolv_dense(tempInt, pJac, varPermu)); 
  return 1;
}

int od_equation_bdf_II::solve(double tinu) {
  double s=pSys->startRecord();
  int errorCode = 0;
  if (reEval) {
    errorCode = lin_solver->evaluate();
    reEval = 0;
    if(errorCode) return errorCode;
  }
  int i;
  int intTemp=2*tree_ndofs;
  int offset = 6*numLoops; 
  double tinu2 = tinu*tinu;
  double* _pRhs = new double[(tree_ndofs>offset)? tree_ndofs : offset];
  matXvec(Fa, pRhs, _pRhs, tree_ndofs, tree_ndofs); 
  for(i=0; i<tree_ndofs; i++) {
    pRhs[tree_ndofs+i]=pRhs[tree_ndofs+i]-_pRhs[i]*tinu;
    pRhs[tree_ndofs+i] /= tinu2;
  }
  if(offset) {
    matXvec(Jt, pRhs, _pRhs, offset, tree_ndofs); 
    for(i=0; i<offset; i++) {
      pRhs[intTemp+i]=(pRhs[intTemp+i]-_pRhs[i])/tinu;
    }  
    lin_solver->solve(pRhs+tree_ndofs, reEval);
    for(i=0; i<offset; i++) {
      pRhs[intTemp+i] *= tinu;
      pRhs[intTemp+offset+i] *= tinu2;
    }
    matTXvec(Jt, pRhs+intTemp, _pRhs, offset, tree_ndofs);  
    for(i=0; i<tree_ndofs; i++) pRhs[i] -= _pRhs[i]-pRhs[i+tree_ndofs]*tinu;
  } else {
    lin_solver->solve(pRhs+tree_ndofs, reEval);
    for(i=0; i<tree_ndofs; i++) pRhs[i] -= -pRhs[i+tree_ndofs]*tinu;
  }
  
  DELARY(_pRhs)
//  pSys->stopRecord(s,2);
  return errorCode;
}

void od_equation_bdf_II::evalJac(double tinu, int debug) {
  //get Fa, Fv and Jt 
  double** pM;
  int i, j;
  double invTinu = 1.0/tinu;
  double invTinu2 = invTinu/tinu;
  double s=pSys->startRecord();
  pSys->updateQ();
  pSys->updatePartials();
  int offset = 6*numLoops; 
  pM = new double*[tree_ndofs];
  for(i=0; i<dim_cols-tree_ndofs; i++) fill(pJac[i], pJac[i]+dim_cols-tree_ndofs, 0.0);
  for(i=0; i<tree_ndofs; i++) {
    fill(Fa[i], Fa[i]+tree_ndofs, 0.0);
    fill(Fv[i], Fv[i]+tree_ndofs, 0.0);
    pM[i] = new double[tree_ndofs]; fill(pM[i], pM[i]+tree_ndofs, 0.0);
  }
  pSys->getM(Fa);
  pSys->parF_parq_dot(Fv);
  pSys->parF_parq(pM);
  for(i=0; i<tree_ndofs; i++)   
    for(j=0; j<tree_ndofs; j++) {
      Fa[i][j]=-Fa[i][j]+Fv[i][j]*invTinu;
      pJac[i][j] = Fa[i][j]+pM[i][j]*invTinu2;
    }
    
    for(i=0; i<offset; i++) { fill(Jt[i], Jt[i]+tree_ndofs, 0.0);}
    for(i=0; i<numLoops; i++) {
      int base, ii, jj;
      double val, valV;
      base = 6*i;
      for(j=0; j<pSys->loop_list[i]->num_nonzero(); j++) {
        ii = pSys->loop_list[i]->row(j)+base+i*6;
        jj = pSys->loop_list[i]->col(j);
        val = pSys->loop_list[i]->jac(j);
        Jt[ii][jj]=val;
        valV = pSys->loop_list[i]->jacV(j);
        pJac[tree_ndofs+ii][jj]=val+valV*invTinu;
        pJac[offset+tree_ndofs+ii][jj]=val;
        pJac[jj][offset+tree_ndofs+ii]=-val;
      }
      for(ii=0; ii<6; ii++) {
        if (pSys->loop_list[i]->if_redundant(ii)) {
          for(jj=0; jj<tree_ndofs; jj++) {
            Jt[base+ii][jj]=0.0;
            pJac[tree_ndofs+base+ii][jj]=0.0;
            pJac[offset+tree_ndofs+base+ii][jj]=0.0;
            pJac[jj][offset+tree_ndofs+base+ii]=0.0;
          }
          pJac[tree_ndofs+base+ii][tree_ndofs+base+ii]=1.0;
          pJac[offset+tree_ndofs+base+ii][offset+tree_ndofs+base+ii]=1.0;
        }
      }
    }
    if(offset) {
      int tempInt = (offset>tree_ndofs) ? offset : tree_ndofs;
      double** pd;
      pd = new double*[tempInt];
      for(i=0; i<tempInt; i++) {
        pd[i] = new double[tempInt];
      }
      matXmatT(Fa, Jt, pd, tree_ndofs, offset, tree_ndofs); 
      for(i=0; i<tree_ndofs; i++) for(j=0; j<offset; j++) pJac[i][tree_ndofs+j] = -pd[i][j];
      matXmatT(Jt, Jt, pd, offset, offset, tree_ndofs); 
      for(i=0; i<offset; i++) for(j=0; j<offset; j++) pJac[tree_ndofs+i][tree_ndofs+j] = -pd[i][j];
      for(i=0; i<tempInt; i++) DELARY(pd[i]) DELARY(pd) 
    }
    for(i=0; i<tree_ndofs; i++) DELARY(pM[i]) DELARY(pM)
    reEval = 1;
    pSys->stopRecord(s,1);
}
